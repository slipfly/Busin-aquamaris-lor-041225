/*!
 * Draggable 3.6.1
 * https://greensock.com
 *
 * @license Copyright 2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).window = t.window || {}) }(this, (function (t) { "use strict"; function e(t, n) { if (t.parentNode && (o || h(t))) { var r = w(t), i = r ? r.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", l = r ? n ? "rect" : "g" : "div", c = 2 !== n ? 0 : 100, d = 3 === n ? 100 : 0, u = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;", p = o.createElementNS ? o.createElementNS(i.replace(/^https/, "http"), l) : o.createElement(l); return n && (r ? (s = s || e(t), p.setAttribute("width", .01), p.setAttribute("height", .01), p.setAttribute("transform", "translate(" + c + "," + d + ")"), s.appendChild(p)) : (a || ((a = e(t)).style.cssText = u), p.style.cssText = u + "width:0.1px;height:0.1px;top:" + d + "px;left:" + c + "px", a.appendChild(p))), p } throw "Need document and parent." } function n(t, e, n, o, r, i, l) { return t.a = e, t.b = n, t.c = o, t.d = r, t.e = i, t.f = l, t } var o, r, i, l, a, s, c, d, u, p = "transform", f = p + "Origin", h = function (t) { var e = t.ownerDocument || t; !(p in t.style) && "msTransform" in t.style && (f = (p = "msTransform") + "Origin"); for (; e.parentNode && (e = e.parentNode);); if (r = window, c = new E, e) { i = (o = e).documentElement, l = e.body; var n = e.createElement("div"), a = e.createElement("div"); l.appendChild(n), n.appendChild(a), n.style.position = "static", n.style[p] = "translate3d(0,0,1px)", d = a.offsetParent !== n, l.removeChild(n) } return e }, g = function (t) { for (var e, n; t && t !== l;)(n = t._gsap) && n.uncache && n.get(t, "x"), n && !n.scaleX && !n.scaleY && n.renderTransform && (n.scaleX = n.scaleY = 1e-4, n.renderTransform(1, n), e ? e.push(n) : e = [n]), t = t.parentNode; return e }, x = [], m = [], v = function () { return r.pageYOffset || o.scrollTop || i.scrollTop || l.scrollTop || 0 }, y = function () { return r.pageXOffset || o.scrollLeft || i.scrollLeft || l.scrollLeft || 0 }, w = function (t) { return t.ownerSVGElement || ("svg" === (t.tagName + "").toLowerCase() ? t : null) }, b = function t(e) { return "fixed" === r.getComputedStyle(e).position || ((e = e.parentNode) && 1 === e.nodeType ? t(e) : void 0) }, T = function (t, n) { var o, i, l, u, h, g, v = w(t), y = t === v, b = v ? x : m, T = t.parentNode; if (t === r) return t; if (b.length || b.push(e(t, 1), e(t, 2), e(t, 3)), o = v ? s : a, v) l = y ? { x: 0, y: 0 } : t.getBBox(), h = (i = t.transform ? t.transform.baseVal : {}).numberOfItems ? (u = (i = 1 < i.numberOfItems ? function (t) { for (var e = new E, n = 0; n < t.numberOfItems; n++)e.multiply(t.getItem(n).matrix); return e }(i) : i.getItem(0).matrix).a * l.x + i.c * l.y, i.b * l.x + i.d * l.y) : (i = c, u = l.x, l.y), n && "g" === t.tagName.toLowerCase() && (u = h = 0), (y ? v : T).appendChild(o), o.setAttribute("transform", "matrix(" + i.a + "," + i.b + "," + i.c + "," + i.d + "," + (i.e + u) + "," + (i.f + h) + ")"); else { if (u = h = 0, d) for (i = t.offsetParent, l = t; (l = l && l.parentNode) && l !== i && l.parentNode;)4 < (r.getComputedStyle(l)[p] + "").length && (u = l.offsetLeft, h = l.offsetTop, l = 0); if ("absolute" !== (g = r.getComputedStyle(t)).position) for (i = t.offsetParent; T && T !== i;)u += T.scrollLeft || 0, h += T.scrollTop || 0, T = T.parentNode; (l = o.style).top = t.offsetTop - h + "px", l.left = t.offsetLeft - u + "px", l[p] = g[p], l[f] = g[f], l.position = "fixed" === g.position ? "fixed" : "absolute", t.parentNode.appendChild(o) } return o }, E = ((u = M.prototype).inverse = function () { var t = this.a, e = this.b, o = this.c, r = this.d, i = this.e, l = this.f, a = t * r - e * o || 1e-10; return n(this, r / a, -e / a, -o / a, t / a, (o * l - r * i) / a, -(t * l - e * i) / a) }, u.multiply = function (t) { var e = this.a, o = this.b, r = this.c, i = this.d, l = this.e, a = this.f, s = t.a, c = t.c, d = t.b, u = t.d, p = t.e, f = t.f; return n(this, s * e + d * r, s * o + d * i, c * e + u * r, c * o + u * i, l + p * e + f * r, a + p * o + f * i) }, u.clone = function () { return new M(this.a, this.b, this.c, this.d, this.e, this.f) }, u.equals = function (t) { var e = this.a, n = this.b, o = this.c, r = this.d, i = this.e, l = this.f; return e === t.a && n === t.b && o === t.c && r === t.d && i === t.e && l === t.f }, u.apply = function (t, e) { void 0 === e && (e = {}); var n = t.x, o = t.y, r = this.a, i = this.b, l = this.c, a = this.d, s = this.e, c = this.f; return e.x = n * r + o * l + s || 0, e.y = n * i + o * a + c || 0, e }, M); function M(t, e, o, r, i, l) { void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === o && (o = 0), void 0 === r && (r = 1), void 0 === i && (i = 0), void 0 === l && (l = 0), n(this, t, e, o, r, i, l) } function X(t, e, n, r) { if (!t || !t.parentNode || (o || h(t)).documentElement === t) return new E; var i = g(t), l = w(t) ? x : m, a = T(t, n), s = l[0].getBoundingClientRect(), c = l[1].getBoundingClientRect(), d = l[2].getBoundingClientRect(), u = a.parentNode, p = !r && b(t), f = new E((c.left - s.left) / 100, (c.top - s.top) / 100, (d.left - s.left) / 100, (d.top - s.top) / 100, s.left + (p ? 0 : y()), s.top + (p ? 0 : v())); if (u.removeChild(a), i) for (s = i.length; s--;)(c = i[s]).scaleX = c.scaleY = 0, c.renderTransform(1, c); return e ? f.inverse() : f } function S() { return "undefined" != typeof window } function Y() { return lt || S() && (lt = window.gsap) && lt.registerPlugin && lt } function D(t) { return "function" == typeof t } function k(t) { return "object" == typeof t } function L(t) { return void 0 === t } function N() { return !1 } function P(t) { return Math.round(1e4 * t) / 1e4 } function C(t, e) { var n = st.createElementNS ? st.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : st.createElement(t); return n.style ? n : st.createElement(t) } function O(t, e) { var n, o = {}; for (n in t) o[n] = e ? t[n] * e : t[n]; return o } function _(t, e) { for (var n, o = t.length; o--;)e ? t[o].style.touchAction = e : t[o].style.removeProperty("touch-action"), (n = t[o].children) && n.length && _(n, e) } function R() { return _t.forEach((function (t) { return t() })) } function A() { return !_t.length && lt.ticker.remove(R) } function B(t) { for (var e = _t.length; e--;)_t[e] === t && _t.splice(e, 1); lt.to(A, { overwrite: !0, delay: 15, duration: 0, onComplete: A, data: "_draggable" }) } function H(t, e, n, o) { if (t.addEventListener) { var r = vt[e]; o = o || (xt ? { passive: !1 } : null), t.addEventListener(r || e, n, o), r && e !== r && t.addEventListener(e, n, o) } } function I(t, e, n) { if (t.removeEventListener) { var o = vt[e]; t.removeEventListener(o || e, n), o && e !== o && t.removeEventListener(e, n) } } function F(t) { t.preventDefault && t.preventDefault(), t.preventManipulation && t.preventManipulation() } function W(t) { wt = t.touches && yt < t.touches.length, I(t.target, "touchend", W) } function V(t) { wt = t.touches && yt < t.touches.length, H(t.target, "touchend", W) } function z(t) { return at.pageYOffset || t.scrollTop || t.documentElement.scrollTop || t.body.scrollTop || 0 } function K(t) { return at.pageXOffset || t.scrollLeft || t.documentElement.scrollLeft || t.body.scrollLeft || 0 } function j(t, e) { H(t, "scroll", e), Wt(t.parentNode) || j(t.parentNode, e) } function G(t, e) { I(t, "scroll", e), Wt(t.parentNode) || G(t.parentNode, e) } function U(t, e) { var n = "x" === e ? "Width" : "Height", o = "scroll" + n, r = "client" + n; return Math.max(0, Wt(t) ? Math.max(ct[o], dt[o]) - (at["inner" + n] || ct[r] || dt[r]) : t[o] - t[r]) } function q(t, e) { var n = U(t, "x"), o = U(t, "y"); Wt(t) ? t = Ft : q(t.parentNode, e), t._gsMaxScrollX = n, t._gsMaxScrollY = o, e || (t._gsScrollX = t.scrollLeft || 0, t._gsScrollY = t.scrollTop || 0) } function $(t, e, n) { var o = t.style; o && (L(o[e]) && (e = ht(e, t) || e), null == n ? o.removeProperty && o.removeProperty(e.replace(/([A-Z])/g, "-$1").toLowerCase()) : o[e] = n) } function Z(t) { return at.getComputedStyle(t instanceof Element ? t : t.host || (t.parentNode || {}).host || t) } function J(t) { if (t === at) return Vt.left = Vt.top = 0, Vt.width = Vt.right = ct.clientWidth || t.innerWidth || dt.clientWidth || 0, Vt.height = Vt.bottom = (t.innerHeight || 0) - 20 < ct.clientHeight ? ct.clientHeight : t.innerHeight || dt.clientHeight || 0, Vt; var e = t.ownerDocument || st, n = L(t.pageX) ? t.nodeType || L(t.left) || L(t.top) ? gt(t)[0].getBoundingClientRect() : t : { left: t.pageX - K(e), top: t.pageY - z(e), right: t.pageX - K(e) + 1, bottom: t.pageY - z(e) + 1 }; return L(n.right) && !L(n.width) ? (n.right = n.left + n.width, n.bottom = n.top + n.height) : L(n.width) && (n = { width: n.right - n.left, height: n.bottom - n.top, right: n.right, left: n.left, bottom: n.bottom, top: n.top }), n } function Q(t, e, n) { var o, r = t.vars, i = r[n], l = t._listeners[e]; return D(i) && (o = i.apply(r.callbackScope || t, r[n + "Params"] || [t.pointerEvent])), l && !1 === t.dispatchEvent(e) && (o = !1), o } function tt(t, e) { var n, o, r, i = gt(t)[0]; return i.nodeType || i === at ? Kt(i, e) : L(t.left) ? { left: o = t.min || t.minX || t.minRotation || 0, top: n = t.min || t.minY || 0, width: (t.max || t.maxX || t.maxRotation || 0) - o, height: (t.max || t.maxY || 0) - n } : (r = { x: 0, y: 0 }, { left: t.left - r.x, top: t.top - r.y, width: t.width, height: t.height }) } function et(t, e, n, o, r, i) { var l, a, s, c = {}; if (e) if (1 !== r && e instanceof Array) { if (c.end = l = [], s = e.length, k(e[0])) for (a = 0; a < s; a++)l[a] = O(e[a], r); else for (a = 0; a < s; a++)l[a] = e[a] * r; n += 1.1, o -= 1.1 } else D(e) ? c.end = function (n) { var o, i, l = e.call(t, n); if (1 !== r) if (k(l)) { for (i in o = {}, l) o[i] = l[i] * r; l = o } else l *= r; return l } : c.end = e; return !n && 0 !== n || (c.max = n), !o && 0 !== o || (c.min = o), i && (c.velocity = 0), c } function nt(t) { var e; return !(!t || !t.getAttribute || t === dt) && (!("true" !== (e = t.getAttribute("data-clickable")) && ("false" === e || !t.onclick && !Bt.test(t.nodeName + "") && "true" !== t.getAttribute("contentEditable"))) || nt(t.parentNode)) } function ot(t, e) { for (var n, o = t.length; o--;)(n = t[o]).ondragstart = n.onselectstart = e ? null : N, lt.set(n, { lazy: !0, userSelect: e ? "text" : "none" }) } function rt(t, e) { t = lt.utils.toArray(t)[0], e = e || {}; var n, o, r, i, l, a, s = document.createElement("div"), c = s.style, d = t.firstChild, u = 0, p = 0, f = t.scrollTop, h = t.scrollLeft, g = t.scrollWidth, x = t.scrollHeight, m = 0, v = 0, y = 0; Xt && !1 !== e.force3D ? (l = "translate3d(", a = "px,0px)") : Dt && (l = "translate(", a = "px)"), this.scrollTop = function (t, e) { if (!arguments.length) return -this.top(); this.top(-t, e) }, this.scrollLeft = function (t, e) { if (!arguments.length) return -this.left(); this.left(-t, e) }, this.left = function (n, o) { if (!arguments.length) return -(t.scrollLeft + p); var r = t.scrollLeft - h, i = p; if ((2 < r || r < -2) && !o) return h = t.scrollLeft, lt.killTweensOf(this, { left: 1, scrollLeft: 1 }), this.left(-h), void (e.onKill && e.onKill()); (n = -n) < 0 ? (p = n - .5 | 0, n = 0) : v < n ? (p = n - v | 0, n = v) : p = 0, (p || i) && (this._skip || (c[Dt] = l + -p + "px," + -u + a), 0 <= p + m && (c.paddingRight = p + m + "px")), t.scrollLeft = 0 | n, h = t.scrollLeft }, this.top = function (n, o) { if (!arguments.length) return -(t.scrollTop + u); var r = t.scrollTop - f, i = u; if ((2 < r || r < -2) && !o) return f = t.scrollTop, lt.killTweensOf(this, { top: 1, scrollTop: 1 }), this.top(-f), void (e.onKill && e.onKill()); (n = -n) < 0 ? (u = n - .5 | 0, n = 0) : y < n ? (u = n - y | 0, n = y) : u = 0, (u || i) && (this._skip || (c[Dt] = l + -p + "px," + -u + a)), t.scrollTop = 0 | n, f = t.scrollTop }, this.maxScrollTop = function () { return y }, this.maxScrollLeft = function () { return v }, this.disable = function () { for (d = s.firstChild; d;)i = d.nextSibling, t.appendChild(d), d = i; t === s.parentNode && t.removeChild(s) }, this.enable = function () { if ((d = t.firstChild) !== s) { for (; d;)i = d.nextSibling, s.appendChild(d), d = i; t.appendChild(s), this.calibrate() } }, this.calibrate = function (e) { var i, l, a, d = t.clientWidth === n; f = t.scrollTop, h = t.scrollLeft, d && t.clientHeight === o && s.offsetHeight === r && g === t.scrollWidth && x === t.scrollHeight && !e || ((u || p) && (l = this.left(), a = this.top(), this.left(-t.scrollLeft), this.top(-t.scrollTop)), i = Z(t), d && !e || (c.display = "block", c.width = "auto", c.paddingRight = "0px", (m = Math.max(0, t.scrollWidth - t.clientWidth)) && (m += parseFloat(i.paddingLeft) + (St ? parseFloat(i.paddingRight) : 0))), c.display = "inline-block", c.position = "relative", c.overflow = "visible", c.verticalAlign = "top", c.boxSizing = "content-box", c.width = "100%", c.paddingRight = m + "px", St && (c.paddingBottom = i.paddingBottom), n = t.clientWidth, o = t.clientHeight, g = t.scrollWidth, x = t.scrollHeight, v = t.scrollWidth - n, y = t.scrollHeight - o, r = s.offsetHeight, c.display = "block", (l || a) && (this.left(l), this.top(a))) }, this.content = s, this.element = t, this._skip = !1, this.enable() } function it(t) { if (S() && document.body) { var e = window && window.navigator; at = window, st = document, ct = st.documentElement, dt = st.body, ut = C("div"), Mt = !!window.PointerEvent, (pt = C("div")).style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab", Et = "grab" === pt.style.cursor ? "grab" : "move", bt = e && -1 !== e.userAgent.toLowerCase().indexOf("android"), mt = "ontouchstart" in ct && "orientation" in at || e && (0 < e.MaxTouchPoints || 0 < e.msMaxTouchPoints), o = C("div"), i = (r = C("div")).style, l = dt, i.display = "inline-block", i.position = "relative", o.style.cssText = r.innerHTML = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden", o.appendChild(r), l.appendChild(o), n = r.offsetHeight + 18 > o.scrollHeight, l.removeChild(o), St = n, vt = function (t) { for (var e = t.split(","), n = (("onpointerdown" in ut ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in ut ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : t).split(",")), o = {}, r = 4; -1 < --r;)o[e[r]] = n[r], o[n[r]] = e[r]; try { ct.addEventListener("test", null, Object.defineProperty({}, "passive", { get: function () { xt = 1 } })) } catch (t) { } return o }("touchstart,touchmove,touchend,touchcancel"), H(st, "touchcancel", N), H(at, "touchmove", N), dt && dt.addEventListener("touchstart", N), H(st, "contextmenu", (function () { for (var t in Rt) Rt[t].isPressed && Rt[t].endDrag() })), lt = ft = Y() } var n, o, r, i, l; lt ? (Tt = lt.plugins.inertia, ht = lt.utils.checkPrefix, Dt = ht(Dt), kt = ht(kt), gt = lt.utils.toArray, Xt = !!ht("perspective")) : t && console.warn("Please gsap.registerPlugin(Draggable)") } var lt, at, st, ct, dt, ut, pt, ft, ht, gt, xt, mt, vt, yt, wt, bt, Tt, Et, Mt, Xt, St, Yt, Dt = "transform", kt = "transformOrigin", Lt = Array.isArray, Nt = 180 / Math.PI, Pt = 1e20, Ct = new E, Ot = Date.now || function () { return (new Date).getTime() }, _t = [], Rt = {}, At = 0, Bt = /^(?:a|input|textarea|button|select)$/i, Ht = 0, It = {}, Ft = {}, Wt = function (t) { return !(t && t !== ct && 9 !== t.nodeType && t !== st.body && t !== at && t.nodeType && t.parentNode) }, Vt = {}, zt = {}, Kt = function (t, e) { e = gt(e)[0]; var n, o, r, i, l, a, s, c, d, u, p, f, h, g, x = t.getBBox && t.ownerSVGElement, m = t.ownerDocument || st; if (t === at) r = z(m), o = (n = K(m)) + (m.documentElement.clientWidth || t.innerWidth || m.body.clientWidth || 0), i = r + ((t.innerHeight || 0) - 20 < m.documentElement.clientHeight ? m.documentElement.clientHeight : t.innerHeight || m.body.clientHeight || 0); else { if (e === at || L(e)) return t.getBoundingClientRect(); n = r = 0, x ? (p = (u = t.getBBox()).width, f = u.height) : (t.viewBox && (u = t.viewBox.baseVal) && (n = u.x || 0, r = u.y || 0, p = u.width, f = u.height), p || (u = "border-box" === (h = Z(t)).boxSizing, p = (parseFloat(h.width) || t.clientWidth || 0) + (u ? 0 : parseFloat(h.borderLeftWidth) + parseFloat(h.borderRightWidth)), f = (parseFloat(h.height) || t.clientHeight || 0) + (u ? 0 : parseFloat(h.borderTopWidth) + parseFloat(h.borderBottomWidth)))), o = p, i = f } return t === e ? { left: n, top: r, width: o - n, height: i - r } : (a = (l = X(e, !0).multiply(X(t))).apply({ x: n, y: r }), s = l.apply({ x: o, y: r }), c = l.apply({ x: o, y: i }), d = l.apply({ x: n, y: i }), n = Math.min(a.x, s.x, c.x, d.x), r = Math.min(a.y, s.y, c.y, d.y), { left: n + ((g = e.parentNode || {}).scrollLeft || 0), top: r + (g.scrollTop || 0), width: Math.max(a.x, s.x, c.x, d.x) - n, height: Math.max(a.y, s.y, c.y, d.y) - r }) }, jt = ((Yt = Gt.prototype).addEventListener = function (t, e) { var n = this._listeners[t] || (this._listeners[t] = []); ~n.indexOf(e) || n.push(e) }, Yt.removeEventListener = function (t, e) { var n = this._listeners[t], o = n && n.indexOf(e) || -1; -1 < o && n.splice(o, 1) }, Yt.dispatchEvent = function (t) { var e, n = this; return (this._listeners[t] || []).forEach((function (o) { return !1 === o.call(n, { type: t, target: n.target }) && (e = !1) })), e }, Gt); function Gt(t) { this._listeners = {}, this.target = t || this } var Ut, qt = (function (t, e) { t.prototype = Object.create(e.prototype), (t.prototype.constructor = t).__proto__ = e }($t, Ut = jt), $t.register = function (t) { lt = t, it() }, $t.create = function (t, e) { return ft || it(!0), gt(t).map((function (t) { return new $t(t, e) })) }, $t.get = function (t) { return Rt[(gt(t)[0] || {})._gsDragID] }, $t.timeSinceDrag = function () { return (Ot() - Ht) / 1e3 }, $t.hitTest = function (t, e, n) { if (t === e) return !1; var o, r, i, l = J(t), a = J(e), s = l.top, c = l.left, d = l.right, u = l.bottom, p = l.width, f = l.height, h = a.left > d || a.right < c || a.top > u || a.bottom < s; return h || !n ? !h : (i = -1 !== (n + "").indexOf("%"), n = parseFloat(n) || 0, (o = { left: Math.max(c, a.left), top: Math.max(s, a.top) }).width = Math.min(d, a.right) - o.left, o.height = Math.min(u, a.bottom) - o.top, !(o.width < 0 || o.height < 0) && (i ? p * f * (n *= .01) <= (r = o.width * o.height) || r >= a.width * a.height * n : o.width > n && o.height > n)) }, $t); function $t(t, e) { var n; function o(e, n) { return parseFloat(be.get(t, e, n)) } function r(t) { return F(t), t.stopImmediatePropagation && t.stopImmediatePropagation(), !1 } function i(e) { if (de.autoScroll && de.isDragging && (he || Xt)) { var n, o, r, l, a, s, c, d, u = t, p = 15 * de.autoScroll; for (he = !1, Ft.scrollTop = null != at.pageYOffset ? at.pageYOffset : null != Ee.documentElement.scrollTop ? Ee.documentElement.scrollTop : Ee.body.scrollTop, Ft.scrollLeft = null != at.pageXOffset ? at.pageXOffset : null != Ee.documentElement.scrollLeft ? Ee.documentElement.scrollLeft : Ee.body.scrollLeft, l = de.pointerX - Ft.scrollLeft, a = de.pointerY - Ft.scrollTop; u && !o;)n = (o = Wt(u.parentNode)) ? Ft : u.parentNode, r = o ? { bottom: Math.max(ct.clientHeight, at.innerHeight || 0), right: Math.max(ct.clientWidth, at.innerWidth || 0), left: 0, top: 0 } : n.getBoundingClientRect(), s = c = 0, se && ((d = n._gsMaxScrollY - n.scrollTop) < 0 ? c = d : a > r.bottom - me && d ? (he = !0, c = Math.min(d, p * (1 - Math.max(0, r.bottom - a) / me) | 0)) : a < r.top + ge && n.scrollTop && (he = !0, c = -Math.min(n.scrollTop, p * (1 - Math.max(0, a - r.top) / ge) | 0)), c && (n.scrollTop += c)), ae && ((d = n._gsMaxScrollX - n.scrollLeft) < 0 ? s = d : l > r.right - xe && d ? (he = !0, s = Math.min(d, p * (1 - Math.max(0, r.right - l) / xe) | 0)) : l < r.left + ve && n.scrollLeft && (he = !0, s = -Math.min(n.scrollLeft, p * (1 - Math.max(0, l - r.left) / ve) | 0)), s && (n.scrollLeft += s)), o && (s || c) && (at.scrollTo(n.scrollLeft, n.scrollTop), Se(de.pointerX + s, de.pointerY + c)), u = n } if (Xt) { var f = de.x, h = de.y; re ? (de.deltaX = f - parseFloat(be.rotation), de.rotation = f, be.rotation = f + "deg", be.renderTransform(1, be)) : w ? (se && (de.deltaY = h - w.top(), w.top(h)), ae && (de.deltaX = f - w.left(), w.left(f))) : oe ? (se && (de.deltaY = h - parseFloat(be.y), be.y = h + "px"), ae && (de.deltaX = f - parseFloat(be.x), be.x = f + "px"), be.renderTransform(1, be)) : (se && (de.deltaY = h - parseFloat(t.style.top || 0), t.style.top = h + "px"), ae && (de.deltaX = f - parseFloat(t.style.left || 0), t.style.left = f + "px")), !N || e || Jt || (!(Jt = !0) === Q(de, "drag", "onDrag") && (ae && (de.x -= de.deltaX), se && (de.y -= de.deltaY), i(!0)), Jt = !1) } Xt = !1 } function l(e, n) { var o, r, l = de.x, a = de.y; t._gsap || (be = lt.core.getCache(t)), be.uncache && lt.getProperty(t, "x"), oe ? (de.x = parseFloat(be.x), de.y = parseFloat(be.y)) : re ? de.x = de.rotation = parseFloat(be.rotation) : w ? (de.y = w.top(), de.x = w.left()) : (de.y = parseFloat(t.style.top || (r = Z(t)) && r.top) || 0, de.x = parseFloat(t.style.left || (r || {}).left) || 0), (Yt || Dt || Bt) && !n && (de.isDragging || de.isThrowing) && (Bt && (It.x = de.x, It.y = de.y, (o = Bt(It)).x !== de.x && (de.x = o.x, Xt = !0), o.y !== de.y && (de.y = o.y, Xt = !0)), Yt && (o = Yt(de.x)) !== de.x && (de.x = o, re && (de.rotation = o), Xt = !0), Dt && ((o = Dt(de.y)) !== de.y && (de.y = o), Xt = !0)), Xt && i(!0), e || (de.deltaX = de.x - l, de.deltaY = de.y - a, Q(de, "throwupdate", "onThrowUpdate")) } function a(t, e, n, o) { return null == e && (e = -Pt), null == n && (n = Pt), D(t) ? function (r) { var i = de.isPressed ? 1 - de.edgeResistance : 1; return t.call(de, n < r ? n + (r - n) * i : r < e ? e + (r - e) * i : r) * o } : Lt(t) ? function (o) { for (var r, i, l = t.length, a = 0, s = Pt; -1 < --l;)(i = (r = t[l]) - o) < 0 && (i = -i), i < s && e <= r && r <= n && (a = l, s = i); return t[a] } : isNaN(t) ? function (t) { return t } : function () { return t * o } } function s() { var n, r, i, l; Y = !1, w ? (w.calibrate(), de.minX = W = -w.maxScrollLeft(), de.minY = dt = -w.maxScrollTop(), de.maxX = A = de.maxY = U = 0, Y = !0) : e.bounds && (n = tt(e.bounds, t.parentNode), re ? (de.minX = W = n.left, de.maxX = A = n.left + n.width, de.minY = dt = de.maxY = U = 0) : L(e.bounds.maxX) && L(e.bounds.maxY) ? (r = tt(t, t.parentNode), de.minX = W = Math.round(o(ie, "px") + n.left - r.left - .5), de.minY = dt = Math.round(o(le, "px") + n.top - r.top - .5), de.maxX = A = Math.round(W + (n.width - r.width)), de.maxY = U = Math.round(dt + (n.height - r.height))) : (n = e.bounds, de.minX = W = n.minX, de.minY = dt = n.minY, de.maxX = A = n.maxX, de.maxY = U = n.maxY), A < W && (de.minX = A, de.maxX = A = W, W = de.minX), U < dt && (de.minY = U, de.maxY = U = dt, dt = de.minY), re && (de.minRotation = W, de.maxRotation = A), Y = !0), e.liveSnap && (i = !0 === e.liveSnap ? e.snap || {} : e.liveSnap, l = Lt(i) || D(i), re ? (Yt = a(l ? i : i.rotation, W, A, 1), Dt = null) : i.points ? Bt = function (t, e, n, o, r, i, l) { return i = i && i < Pt ? i * i : Pt, D(t) ? function (a) { var s, c, d, u = de.isPressed ? 1 - de.edgeResistance : 1, p = a.x, f = a.y; return a.x = p = n < p ? n + (p - n) * u : p < e ? e + (p - e) * u : p, a.y = f = r < f ? r + (f - r) * u : f < o ? o + (f - o) * u : f, (s = t.call(de, a)) !== a && (a.x = s.x, a.y = s.y), 1 !== l && (a.x *= l, a.y *= l), i < Pt && (c = a.x - p, d = a.y - f, i < c * c + d * d && (a.x = p, a.y = f)), a } : Lt(t) ? function (e) { for (var n, o, r, l, a = t.length, s = 0, c = Pt; -1 < --a;)(l = (n = (r = t[a]).x - e.x) * n + (o = r.y - e.y) * o) < c && (s = a, c = l); return c <= i ? t[s] : e } : function (t) { return t } }(l ? i : i.points, W, A, dt, U, i.radius, w ? -1 : 1) : (ae && (Yt = a(l ? i : i.x || i.left || i.scrollLeft, W, A, w ? -1 : 1)), se && (Dt = a(l ? i : i.y || i.top || i.scrollTop, dt, U, w ? -1 : 1)))) } function c() { de.isThrowing = !1, Q(de, "throwcomplete", "onThrowComplete") } function d() { de.isThrowing = !1 } function u(n, o) { var r, i, a, s; n && Tt ? (!0 === n && (r = e.snap || e.liveSnap || {}, i = Lt(r) || D(r), n = { resistance: (e.throwResistance || e.resistance || 1e3) / (re ? 10 : 1) }, re ? n.rotation = et(de, i ? r : r.rotation, A, W, 1, o) : (ae && (n[ie] = et(de, i ? r : r.points || r.x || r.left, A, W, w ? -1 : 1, o || "x" === de.lockedAxis)), se && (n[le] = et(de, i ? r : r.points || r.y || r.top, U, dt, w ? -1 : 1, o || "y" === de.lockedAxis)), (r.points || Lt(r) && k(r[0])) && (n.linkedProps = ie + "," + le, n.radius = r.radius))), de.isThrowing = !0, s = isNaN(e.overshootTolerance) ? 1 === e.edgeResistance ? 0 : 1 - de.edgeResistance + .2 : e.overshootTolerance, n.duration || (n.duration = { max: Math.max(e.minDuration || 0, "maxDuration" in e ? e.maxDuration : 2), min: isNaN(e.minDuration) ? 0 === s || k(n) && 1e3 < n.resistance ? 0 : .5 : e.minDuration, overshoot: s }), de.tween = a = lt.to(w || t, { inertia: n, data: "_draggable", onComplete: c, onInterrupt: d, onUpdate: e.fastMode ? Q : l, onUpdateParams: e.fastMode ? [de, "onthrowupdate", "onThrowUpdate"] : r && r.radius ? [!1, !0] : [] }), e.fastMode || (w && (w._skip = !0), a.render(1e9, !0, !0), l(!0, !0), de.endX = de.x, de.endY = de.y, re && (de.endRotation = de.x), a.play(0), l(!0, !0), w && (w._skip = !1))) : Y && de.applyBounds() } function p(e) { var n, o = jt; jt = X(t.parentNode, !0), e && de.isPressed && !jt.equals(o || new E) && (n = o.inverse().apply({ x: b, y: T }), jt.apply(n, n), b = n.x, T = n.y), jt.equals(Ct) && (jt = null) } function f() { var e, n, r, a = 1 - de.edgeResistance, c = Te ? K(Ee) : 0, d = Te ? z(Ee) : 0; p(!1), zt.x = de.pointerX - c, zt.y = de.pointerY - d, jt && jt.apply(zt, zt), b = zt.x, T = zt.y, Xt && (Se(de.pointerX, de.pointerY), i(!0)), w ? (s(), S = w.top(), M = w.left()) : (Me() ? (l(!0, !0), s()) : de.applyBounds(), re ? (e = t.ownerSVGElement ? [be.xOrigin - t.getBBox().x, be.yOrigin - t.getBBox().y] : (Z(t)[kt] || "0 0").split(" "), xt = de.rotationOrigin = X(t).apply({ x: parseFloat(e[0]) || 0, y: parseFloat(e[1]) || 0 }), l(!0, !0), n = de.pointerX - xt.x - c, r = xt.y - de.pointerY + d, M = de.x, S = de.y = Math.atan2(r, n) * Nt) : (S = o(le, "px"), M = o(ie, "px"))), Y && a && (A < M ? M = A + (M - A) / a : M < W && (M = W - (W - M) / a), re || (U < S ? S = U + (S - U) / a : S < dt && (S = dt - (dt - S) / a))), de.startX = M = P(M), de.startY = S = P(S) } function h() { !pt.parentNode || Me() || de.isDragging || pt.parentNode.removeChild(pt) } function g(n, o) { var r; if (!y || de.isPressed || !n || !("mousedown" !== n.type && "pointerdown" !== n.type || o) && Ot() - we < 30 && vt[de.pointerEvent.type]) ee && n && y && F(n); else { if (Gt = Me(), de.pointerEvent = n, vt[n.type] ? (H(Kt = ~n.type.indexOf("touch") ? n.currentTarget || n.target : Ee, "touchend", Ye), H(Kt, "touchmove", Xe), H(Kt, "touchcancel", Ye), H(Ee, "touchstart", V)) : (Kt = null, H(Ee, "mousemove", Xe)), Zt = null, Mt && Kt || (H(Ee, "mouseup", Ye), n && n.target && H(n.target, "mouseup", Ye)), Vt = ye.call(de, n.target) && !1 === e.dragClickables && !o) return H(n.target, "change", Ye), Q(de, "pressInit", "onPressInit"), Q(de, "press", "onPress"), ot(ue, !0), void (ee = !1); if (qt = !(!Kt || ae == se || !1 === de.vars.allowNativeTouchScrolling || de.vars.allowContextMenu && n && (n.ctrlKey || 2 < n.which)) && (ae ? "y" : "x"), (ee = !qt && !de.allowEventDefault) && (F(n), H(at, "touchforcechange", F)), n.changedTouches ? (n = ut = n.changedTouches[0], ht = n.identifier) : n.pointerId ? ht = n.pointerId : ut = ht = null, yt++, function (t) { _t.push(t), 1 === _t.length && lt.ticker.add(R) }(i), T = de.pointerY = n.pageY, b = de.pointerX = n.pageX, Q(de, "pressInit", "onPressInit"), (qt || de.autoScroll) && q(t.parentNode), !t.parentNode || !de.autoScroll || w || re || !t.parentNode._gsMaxScrollX || pt.parentNode || t.getBBox || (pt.style.width = t.parentNode.scrollWidth + "px", t.parentNode.appendChild(pt)), f(), de.tween && de.tween.kill(), de.isThrowing = !1, lt.killTweensOf(w || t, pe, !0), w && lt.killTweensOf(t, { scrollTo: 1 }, !0), de.tween = de.lockedAxis = null, !e.zIndexBoost && (re || w || e.zIndexBoost), de.isPressed = !0, N = !(!e.onDrag && !de._listeners.drag), C = !(!e.onMove && !de._listeners.move), !re && (!1 !== e.cursor || e.activeCursor)) for (r = ue.length; -1 < --r;)lt.set(ue[r], { cursor: e.activeCursor || e.cursor || ("grab" === Et ? "grabbing" : Et) }); Q(de, "press", "onPress") } } function x(e) { if (e && de.isDragging && !w) { var n = e.target || t.parentNode, o = n.scrollLeft - n._gsScrollX, r = n.scrollTop - n._gsScrollY; (o || r) && (jt ? (b -= o * jt.a + r * jt.c, T -= r * jt.d + o * jt.b) : (b -= o, T -= r), n._gsScrollX += o, n._gsScrollY += r, Se(de.pointerX, de.pointerY)) } } function m(t) { var e = Ot(), n = e - we < 40, o = e - fe < 40, r = n && Qt === we, i = de.pointerEvent && de.pointerEvent.defaultPrevented, l = n && te === we, a = t.isTrusted || null == t.isTrusted && n && r; if ((r || o && !1 !== de.vars.suppressClickOnDrag) && t.stopImmediatePropagation && t.stopImmediatePropagation(), n && (!de.pointerEvent || !de.pointerEvent.defaultPrevented) && (!r || a && !l)) return a && r && (te = we), void (Qt = we); (de.isPressed || o || n) && (a && t.detail && n && !i || F(t)), n || o || (t && t.target && (de.pointerEvent = t), Q(de, "click", "onClick")) } function v(t) { return jt ? { x: t.x * jt.a + t.y * jt.c + jt.e, y: t.x * jt.b + t.y * jt.d + jt.f } : { x: t.x, y: t.y } } n = Ut.call(this) || this, ft || it(1), t = gt(t)[0], Tt = Tt || lt.plugins.inertia, n.vars = e = O(e || {}), n.target = t, n.x = n.y = n.rotation = 0, n.dragResistance = parseFloat(e.dragResistance) || 0, n.edgeResistance = isNaN(e.edgeResistance) ? 1 : parseFloat(e.edgeResistance) || 0, n.lockAxis = e.lockAxis, n.autoScroll = e.autoScroll || 0, n.lockedAxis = null, n.allowEventDefault = !!e.allowEventDefault, lt.getProperty(t, "x"); var y, w, b, T, M, S, Y, N, C, A, W, U, dt, ut, ht, xt, Xt, St, Yt, Dt, Bt, Vt, Kt, jt, Gt, qt, Zt, Jt, Qt, te, ee, ne = (e.type || "x,y").toLowerCase(), oe = ~ne.indexOf("x") || ~ne.indexOf("y"), re = -1 !== ne.indexOf("rotation"), ie = re ? "rotation" : oe ? "x" : "left", le = oe ? "y" : "top", ae = !(!~ne.indexOf("x") && !~ne.indexOf("left") && "scroll" !== ne), se = !(!~ne.indexOf("y") && !~ne.indexOf("top") && "scroll" !== ne), ce = e.minimumMovement || 2, de = function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }(n), ue = gt(e.trigger || e.handle || t), pe = {}, fe = 0, he = !1, ge = e.autoScrollMarginTop || 40, xe = e.autoScrollMarginRight || 40, me = e.autoScrollMarginBottom || 40, ve = e.autoScrollMarginLeft || 40, ye = e.clickableTest || nt, we = 0, be = t._gsap || lt.core.getCache(t), Te = function t(e) { return "fixed" === Z(e).position || ((e = e.parentNode) && 1 === e.nodeType ? t(e) : void 0) }(t), Ee = t.ownerDocument || st, Me = function () { return de.tween && de.tween.isActive() }, Xe = function (e) { var n, o, r, i, l, a, s = e; if (y && !wt && de.isPressed && e) { if (n = (de.pointerEvent = e).changedTouches) { if ((e = n[0]) !== ut && e.identifier !== ht) { for (i = n.length; -1 < --i && (e = n[i]).identifier !== ht && e.target !== t;); if (i < 0) return } } else if (e.pointerId && ht && e.pointerId !== ht) return; Kt && qt && !Zt && (zt.x = e.pageX, zt.y = e.pageY, jt && jt.apply(zt, zt), o = zt.x, r = zt.y, ((l = Math.abs(o - b)) !== (a = Math.abs(r - T)) && (ce < l || ce < a) || bt && qt === Zt) && (Zt = a < l && ae ? "x" : "y", qt && Zt !== qt && H(at, "touchforcechange", F), !1 !== de.vars.lockAxisOnTouchScroll && ae && se && (de.lockedAxis = "x" === Zt ? "y" : "x", D(de.vars.onLockAxis) && de.vars.onLockAxis.call(de, s)), bt && qt === Zt)) ? Ye(s) : (ee = de.allowEventDefault || qt && (!Zt || qt === Zt) || !1 === s.cancelable ? ee && !1 : (F(s), !0), de.autoScroll && (he = !0), Se(e.pageX, e.pageY, C)) } else ee && e && y && F(e) }, Se = function (t, e, n) { var o, r, i, l, a, s, c = 1 - de.dragResistance, d = 1 - de.edgeResistance, u = de.pointerX, p = de.pointerY, f = S, h = de.x, g = de.y, x = de.endX, m = de.endY, v = de.endRotation, y = Xt; de.pointerX = t, de.pointerY = e, Te && (t -= K(Ee), e -= z(Ee)), re ? (l = Math.atan2(xt.y - e, t - xt.x) * Nt, 180 < (a = de.y - l) ? (S -= 360, de.y = l) : a < -180 && (S += 360, de.y = l), i = de.x !== M || Math.abs(S - l) > ce ? (de.y = l, M + (S - l) * c) : M) : (jt && (s = t * jt.a + e * jt.c + jt.e, e = t * jt.b + e * jt.d + jt.f, t = s), (r = e - T) < ce && -ce < r && (r = 0), (o = t - b) < ce && -ce < o && (o = 0), (de.lockAxis || de.lockedAxis) && (o || r) && ((s = de.lockedAxis) || (de.lockedAxis = s = ae && Math.abs(o) > Math.abs(r) ? "y" : se ? "x" : null, s && D(de.vars.onLockAxis) && de.vars.onLockAxis.call(de, de.pointerEvent)), "y" === s ? r = 0 : "x" === s && (o = 0)), i = P(M + o * c), l = P(S + r * c)), (Yt || Dt || Bt) && (de.x !== i || de.y !== l && !re) ? (Bt && (It.x = i, It.y = l, i = P((s = Bt(It)).x), l = P(s.y)), Yt && (i = P(Yt(i))), Dt && (l = P(Dt(l)))) : Y && (A < i ? i = A + Math.round((i - A) * d) : i < W && (i = W + Math.round((i - W) * d)), re || (U < l ? l = Math.round(U + (l - U) * d) : l < dt && (l = Math.round(dt + (l - dt) * d)))), de.x === i && (de.y === l || re) || (re ? (de.endRotation = de.x = de.endX = i, Xt = !0) : (se && (de.y = de.endY = l, Xt = !0), ae && (de.x = de.endX = i, Xt = !0)), n && !1 === Q(de, "move", "onMove") ? (de.pointerX = u, de.pointerY = p, S = f, de.x = h, de.y = g, de.endX = x, de.endY = m, de.endRotation = v, Xt = y) : !de.isDragging && de.isPressed && (de.isDragging = !0, Q(de, "dragstart", "onDragStart"))) }, Ye = function n(o, r) { if (y && de.isPressed && (!o || null == ht || r || !(o.pointerId && o.pointerId !== ht && o.target !== t || o.changedTouches && !function (t, e) { for (var n = t.length; n--;)if (t[n].identifier === e) return !0 }(o.changedTouches, ht)))) { de.isPressed = !1; var l, a, s, c, d, p = o, f = de.isDragging, g = de.vars.allowContextMenu && o && (o.ctrlKey || 2 < o.which), x = lt.delayedCall(.001, h); if (Kt ? (I(Kt, "touchend", n), I(Kt, "touchmove", Xe), I(Kt, "touchcancel", n), I(Ee, "touchstart", V)) : I(Ee, "mousemove", Xe), I(at, "touchforcechange", F), Mt && Kt || (I(Ee, "mouseup", n), o && o.target && I(o.target, "mouseup", n)), Xt = !1, f && (fe = Ht = Ot(), de.isDragging = !1), Vt && !g) return o && (I(o.target, "change", n), de.pointerEvent = p), ot(ue, !1), Q(de, "release", "onRelease"), Q(de, "click", "onClick"), void (Vt = !1); if (B(i), !re) for (a = ue.length; -1 < --a;)$(ue[a], "cursor", e.cursor || (!1 !== e.cursor ? Et : null)); if (yt--, o) { if ((l = o.changedTouches) && (o = l[0]) !== ut && o.identifier !== ht) { for (a = l.length; -1 < --a && (o = l[a]).identifier !== ht && o.target !== t;); if (a < 0) return } de.pointerEvent = p, de.pointerX = o.pageX, de.pointerY = o.pageY } return g && p ? (F(p), ee = !0, Q(de, "release", "onRelease")) : p && !f ? (ee = !1, Gt && (e.snap || e.bounds) && u(e.inertia || e.throwProps), Q(de, "release", "onRelease"), bt && "touchmove" === p.type || -1 !== p.type.indexOf("cancel") || (Q(de, "click", "onClick"), Ot() - we < 300 && Q(de, "doubleclick", "onDoubleClick"), c = p.target || t, we = Ot(), d = function () { we === Qt || !de.enabled() || de.isPressed || p.defaultPrevented || (c.click ? c.click() : Ee.createEvent && ((s = Ee.createEvent("MouseEvents")).initMouseEvent("click", !0, !0, at, 1, de.pointerEvent.screenX, de.pointerEvent.screenY, de.pointerX, de.pointerY, !1, !1, !1, !1, 0, null), c.dispatchEvent(s))) }, bt || p.defaultPrevented || lt.delayedCall(.05, d))) : (u(e.inertia || e.throwProps), de.allowEventDefault || !p || !1 === e.dragClickables && ye.call(de, p.target) || !f || qt && (!Zt || qt !== Zt) || !1 === p.cancelable ? ee = !1 : (ee = !0, F(p)), Q(de, "release", "onRelease")), Me() && x.duration(de.tween.duration()), f && Q(de, "dragend", "onDragEnd"), !0 } ee && o && y && F(o) }; return (St = $t.get(t)) && St.kill(), n.startDrag = function (e, n) { var o, r, i, l; g(e || de.pointerEvent, !0), n && !de.hitTest(e || de.pointerEvent) && (o = J(e || de.pointerEvent), r = J(t), i = v({ x: o.left + o.width / 2, y: o.top + o.height / 2 }), l = v({ x: r.left + r.width / 2, y: r.top + r.height / 2 }), b -= i.x - l.x, T -= i.y - l.y), de.isDragging || (de.isDragging = !0, Q(de, "dragstart", "onDragStart")) }, n.drag = Xe, n.endDrag = function (t) { return Ye(t || de.pointerEvent, !0) }, n.timeSinceDrag = function () { return de.isDragging ? 0 : (Ot() - fe) / 1e3 }, n.timeSinceClick = function () { return (Ot() - we) / 1e3 }, n.hitTest = function (t, e) { return $t.hitTest(de.target, t, e) }, n.getDirection = function (e, n) { var o, r, i, l, a, s, c = "velocity" === e && Tt ? e : k(e) && !re ? "element" : "start"; return "element" === c && (a = J(de.target), s = J(e)), o = "start" === c ? de.x - M : "velocity" === c ? Tt.getVelocity(t, ie) : a.left + a.width / 2 - (s.left + s.width / 2), re ? o < 0 ? "counter-clockwise" : "clockwise" : (n = n || 2, r = "start" === c ? de.y - S : "velocity" === c ? Tt.getVelocity(t, le) : a.top + a.height / 2 - (s.top + s.height / 2), l = (i = Math.abs(o / r)) < 1 / n ? "" : o < 0 ? "left" : "right", i < n && ("" !== l && (l += "-"), l += r < 0 ? "up" : "down"), l) }, n.applyBounds = function (n, o) { var r, a, c, d, p, f; if (n && e.bounds !== n) return e.bounds = n, de.update(!0, o); if (l(!0), s(), Y && !Me()) { if (r = de.x, a = de.y, A < r ? r = A : r < W && (r = W), U < a ? a = U : a < dt && (a = dt), (de.x !== r || de.y !== a) && (c = !0, de.x = de.endX = r, re ? de.endRotation = r : de.y = de.endY = a, i(Xt = !0), de.autoScroll && !de.isDragging)) for (q(t.parentNode), d = t, Ft.scrollTop = null != at.pageYOffset ? at.pageYOffset : null != Ee.documentElement.scrollTop ? Ee.documentElement.scrollTop : Ee.body.scrollTop, Ft.scrollLeft = null != at.pageXOffset ? at.pageXOffset : null != Ee.documentElement.scrollLeft ? Ee.documentElement.scrollLeft : Ee.body.scrollLeft; d && !f;)p = (f = Wt(d.parentNode)) ? Ft : d.parentNode, se && p.scrollTop > p._gsMaxScrollY && (p.scrollTop = p._gsMaxScrollY), ae && p.scrollLeft > p._gsMaxScrollX && (p.scrollLeft = p._gsMaxScrollX), d = p; de.isThrowing && (c || de.endX > A || de.endX < W || de.endY > U || de.endY < dt) && u(e.inertia || e.throwProps, c) } return de }, n.update = function (e, n, o) { var r = de.x, a = de.y; return p(!n), e ? de.applyBounds() : (Xt && o && i(!0), l(!0)), n && (Se(de.pointerX, de.pointerY), Xt && i(!0)), de.isPressed && !n && (ae && .01 < Math.abs(r - de.x) || se && .01 < Math.abs(a - de.y) && !re) && f(), de.autoScroll && (q(t.parentNode, de.isDragging), he = de.isDragging, i(!0), G(t, x), j(t, x)), de }, n.enable = function (n) { var o, i, l, a = { lazy: !0 }; if (re || !1 === e.cursor || (a.cursor = e.cursor || Et), lt.utils.checkPrefix("touchCallout") && (a.touchCallout = "none"), "soft" !== n) { for (_(ue, ae == se ? "none" : e.allowNativeTouchScrolling && t.scrollHeight === t.clientHeight == (t.scrollWidth === t.clientHeight) || e.allowEventDefault ? "manipulation" : ae ? "pan-y" : "pan-x"), i = ue.length; -1 < --i;)l = ue[i], Mt || H(l, "mousedown", g), H(l, "touchstart", g), H(l, "click", m, !0), lt.set(l, a), l.getBBox && l.ownerSVGElement && lt.set(l.ownerSVGElement, { touchAction: ae == se ? "none" : e.allowNativeTouchScrolling || e.allowEventDefault ? "manipulation" : ae ? "pan-y" : "pan-x" }), e.allowContextMenu || H(l, "contextmenu", r); ot(ue, !1) } return j(t, x), y = !0, Tt && "soft" !== n && Tt.track(w || t, oe ? "x,y" : re ? "rotation" : "top,left"), t._gsDragID = o = "d" + At++, Rt[o] = de, w && (w.enable(), w.element._gsDragID = o), (e.bounds || re) && f(), e.bounds && de.applyBounds(), de }, n.disable = function (e) { var n, o, l = de.isDragging; if (!re) for (n = ue.length; -1 < --n;)$(ue[n], "cursor", null); if ("soft" !== e) { for (_(ue, null), n = ue.length; -1 < --n;)$(o = ue[n], "touchCallout", null), I(o, "mousedown", g), I(o, "touchstart", g), I(o, "click", m), I(o, "contextmenu", r); ot(ue, !0), Kt && (I(Kt, "touchcancel", Ye), I(Kt, "touchend", Ye), I(Kt, "touchmove", Xe)), I(Ee, "mouseup", Ye), I(Ee, "mousemove", Xe) } return G(t, x), y = !1, Tt && "soft" !== e && Tt.untrack(w || t, oe ? "x,y" : re ? "rotation" : "top,left"), w && w.disable(), B(i), de.isDragging = de.isPressed = Vt = !1, l && Q(de, "dragend", "onDragEnd"), de }, n.enabled = function (t, e) { return arguments.length ? t ? de.enable(e) : de.disable(e) : y }, n.kill = function () { return de.isThrowing = !1, de.tween && de.tween.kill(), de.disable(), lt.set(ue, { clearProps: "userSelect" }), delete Rt[t._gsDragID], de }, ~ne.indexOf("scroll") && (w = n.scrollProxy = new rt(t, function (t, e) { for (var n in e) n in t || (t[n] = e[n]); return t }({ onKill: function () { de.isPressed && Ye(null) } }, e)), t.style.overflowY = se && !mt ? "auto" : "hidden", t.style.overflowX = ae && !mt ? "auto" : "hidden", t = w.content), re ? pe.rotation = 1 : (ae && (pe[ie] = 1), se && (pe[le] = 1)), be.force3D = !("force3D" in e) || e.force3D, n.enable(), n } !function (t, e) { for (var n in e) n in t || (t[n] = e[n]) }(qt.prototype, { pointerX: 0, pointerY: 0, startX: 0, startY: 0, deltaX: 0, deltaY: 0, isDragging: !1, isPressed: !1 }), qt.zIndex = 1e3, qt.version = "3.6.1", Y() && lt.registerPlugin(qt), t.Draggable = qt, t.default = qt, "undefined" == typeof window || window !== t ? Object.defineProperty(t, "__esModule", { value: !0 }) : delete t.default }));